"use server"

import { createServerSupabaseClient } from "./supabase/server"
import { events } from "@/data/events"
import type { Event } from "@/types/event"

// FunÃ§Ã£o para enviar notificaÃ§Ã£o via WhatsApp usando Twilio
async function sendWhatsAppMessage(phoneNumber: string, message: string) {
  try {
    // Verificar se as variÃ¡veis de ambiente do Twilio estÃ£o configuradas
    const accountSid = process.env.TWILIO_ACCOUNT_SID
    const authToken = process.env.TWILIO_AUTH_TOKEN
    const twilioPhoneNumber = process.env.TWILIO_PHONE_NUMBER

    if (!accountSid || !authToken || !twilioPhoneNumber) {
      console.error("VariÃ¡veis de ambiente do Twilio nÃ£o configuradas")
      return {
        success: false,
        error:
          "ConfiguraÃ§Ã£o do Twilio incompleta. Verifique as variÃ¡veis de ambiente TWILIO_ACCOUNT_SID, TWILIO_AUTH_TOKEN e TWILIO_PHONE_NUMBER.",
      }
    }

    // Modo de teste - sempre retornar sucesso simulado em ambiente de desenvolvimento
    // Isso permite testar a funcionalidade sem depender do Twilio
    if (process.env.NODE_ENV === "development") {
      console.log("Executando em modo de desenvolvimento - simulando envio bem-sucedido")
      console.log(`SimulaÃ§Ã£o: Mensagem enviada para ${phoneNumber}`)
      console.log(`ConteÃºdo da mensagem: ${message}`)
      return {
        success: true,
        messageId: "TESTE-" + Date.now(),
        testMode: true,
      }
    }

    // Em produÃ§Ã£o, tentamos usar o Twilio
    try {
      // Importar o mÃ³dulo Twilio de forma segura
      const twilioModule = await import("twilio")

      // Verificar se o mÃ³dulo foi importado corretamente
      if (!twilioModule) {
        throw new Error("Falha ao importar o mÃ³dulo Twilio")
      }

      // Tentar diferentes formas de acessar o construtor Twilio
      let TwilioClient

      if (typeof twilioModule.default === "function") {
        // Se o mÃ³dulo exporta uma funÃ§Ã£o como default
        TwilioClient = twilioModule.default
      } else if (twilioModule.Twilio) {
        // Se o mÃ³dulo exporta uma classe Twilio
        TwilioClient = twilioModule.Twilio
      } else {
        // Ãšltima tentativa - usar o prÃ³prio mÃ³dulo como construtor
        TwilioClient = twilioModule
      }

      // Verificar se temos um construtor vÃ¡lido
      if (!TwilioClient) {
        throw new Error("NÃ£o foi possÃ­vel encontrar o construtor Twilio no mÃ³dulo importado")
      }

      // Criar cliente Twilio
      const client =
        typeof TwilioClient === "function"
          ? new TwilioClient(accountSid, authToken)
          : TwilioClient(accountSid, authToken)

      // Verificar se o cliente foi criado corretamente
      if (!client || !client.messages || typeof client.messages.create !== "function") {
        throw new Error("Cliente Twilio invÃ¡lido ou nÃ£o possui o mÃ©todo messages.create")
      }

      // Formatar o nÃºmero de telefone para o formato do WhatsApp
      const formattedPhoneNumber = phoneNumber.startsWith("+") ? `whatsapp:${phoneNumber}` : `whatsapp:+${phoneNumber}`
      const formattedTwilioNumber = twilioPhoneNumber.startsWith("whatsapp:")
        ? twilioPhoneNumber
        : `whatsapp:${twilioPhoneNumber}`

      // Enviar mensagem
      const result = await client.messages.create({
        body: message,
        from: formattedTwilioNumber,
        to: formattedPhoneNumber,
      })

      console.log(`Mensagem enviada para ${phoneNumber}, SID: ${result.sid}`)
      return { success: true, messageId: result.sid }
    } catch (twilioError) {
      console.error("Erro com o Twilio:", twilioError)

      // Em produÃ§Ã£o, retornar erro
      return {
        success: false,
        error: `Erro com o Twilio: ${twilioError instanceof Error ? twilioError.message : "Erro desconhecido"}`,
      }
    }
  } catch (error) {
    console.error("Erro ao enviar mensagem WhatsApp:", error)

    // Em produÃ§Ã£o, retornar erro
    if (process.env.NODE_ENV !== "development") {
      return {
        success: false,
        error: `Erro geral ao enviar mensagem: ${error instanceof Error ? error.message : "Erro desconhecido"}`,
      }
    }

    // Em desenvolvimento, simular sucesso mesmo em caso de erro
    console.log("Executando em modo de desenvolvimento - simulando envio bem-sucedido apÃ³s erro")
    return {
      success: true,
      messageId: "TESTE-ERRO-" + Date.now(),
      testMode: true,
      errorCaught: true,
    }
  }
}

// FunÃ§Ã£o para verificar eventos prÃ³ximos e enviar notificaÃ§Ãµes
export async function checkUpcomingEventsAndNotify() {
  try {
    console.log("Iniciando verificaÃ§Ã£o de eventos prÃ³ximos...")
    const supabase = createServerSupabaseClient()
    const now = new Date()
    console.log("Data/hora atual:", now.toISOString())

    // Obter todos os assinantes ativos
    console.log("Buscando assinantes ativos...")
    const { data: subscribers, error: subscribersError } = await supabase
      .from("whatsapp_subscribers")
      .select("*")
      .eq("active", true)

    if (subscribersError) {
      console.error("Erro ao obter assinantes:", subscribersError)
      return {
        success: false,
        error: `Erro ao obter assinantes: ${subscribersError.message}`,
      }
    }

    console.log(`Encontrados ${subscribers?.length || 0} assinantes ativos`)

    // Se nÃ£o houver assinantes, retornar sucesso mas sem notificaÃ§Ãµes
    if (!subscribers || subscribers.length === 0) {
      console.log("Nenhum assinante ativo encontrado")
      return {
        success: true,
        message: "Nenhum assinante ativo encontrado",
        notificationsSent: 0,
        results: [],
      }
    }

    // Obter todas as preferÃªncias de notificaÃ§Ã£o
    console.log("Buscando preferÃªncias de notificaÃ§Ã£o...")
    const { data: notifications, error: notificationsError } = await supabase.from("event_notifications").select("*")

    if (notificationsError) {
      console.error("Erro ao obter notificaÃ§Ãµes:", notificationsError)
      return {
        success: false,
        error: `Erro ao obter notificaÃ§Ãµes: ${notificationsError.message}`,
      }
    }

    console.log(`Encontradas ${notifications?.length || 0} preferÃªncias de notificaÃ§Ã£o`)

    // Para cada assinante, verificar eventos prÃ³ximos
    const notificationResults = []

    // Modo de teste: verificar todos os eventos para o primeiro assinante
    // Isso garante que tenhamos algo para mostrar mesmo que nenhum evento esteja a 30 minutos de comeÃ§ar
    if (subscribers.length > 0) {
      console.log("Executando modo de teste para o primeiro assinante...")
      const testSubscriber = subscribers[0]
      console.log("Assinante de teste:", testSubscriber.phone_number)

      const subscriberEventIds = notifications
        .filter((n) => n.subscriber_id === testSubscriber.id)
        .map((n) => n.event_id)

      console.log(`Assinante de teste tem ${subscriberEventIds.length} eventos selecionados`)

      // Se o assinante tiver eventos selecionados
      if (subscriberEventIds.length > 0) {
        // Pegar o primeiro evento para teste
        const testEvent = events.find((event) => subscriberEventIds.includes(event.id))

        if (testEvent) {
          console.log(`Enviando notificaÃ§Ã£o de teste para o evento: ${testEvent.name}`)
          // Criar uma mensagem de teste
          const message = `ðŸŽ® *Aion Classic Timer - TESTE* ðŸŽ®\n\nEsta Ã© uma mensagem de teste para o evento *${testEvent.name}*. Em produÃ§Ã£o, vocÃª receberÃ¡ notificaÃ§Ãµes 30 minutos antes de cada evento comeÃ§ar.`

          // Enviar a notificaÃ§Ã£o de teste
          const result = await sendWhatsAppMessage(testSubscriber.phone_number, message)
          console.log("Resultado do envio de teste:", result)

          notificationResults.push({
            subscriber: testSubscriber.phone_number,
            event: testEvent.name,
            success: result.success,
            error: result.success ? null : result.error,
            isTest: true,
            testMode: result.testMode || false,
          })
        } else {
          console.log("Nenhum evento vÃ¡lido encontrado para o assinante de teste")
        }
      } else {
        console.log("Assinante de teste nÃ£o tem eventos selecionados")
      }
    }

    // Verificar eventos reais que comeÃ§arÃ£o em 30 minutos
    console.log("Verificando eventos reais que comeÃ§arÃ£o em 30 minutos...")
    for (const subscriber of subscribers) {
      // Obter os IDs dos eventos que o assinante deseja ser notificado
      const subscriberEventIds = notifications.filter((n) => n.subscriber_id === subscriber.id).map((n) => n.event_id)

      // Se o assinante nÃ£o tiver eventos selecionados, pular
      if (subscriberEventIds.length === 0) {
        continue
      }

      // Filtrar apenas os eventos que o assinante deseja ser notificado
      const subscriberEvents = events.filter((event) => subscriberEventIds.includes(event.id))

      // Para cada evento, verificar se estÃ¡ prÃ³ximo de comeÃ§ar
      for (const event of subscriberEvents) {
        const nextEventTime = getNextEventTime(event, now)

        if (nextEventTime) {
          // Calcular a diferenÃ§a de tempo em minutos
          const diffMinutes = (nextEventTime.getTime() - now.getTime()) / (1000 * 60)

          // Se o evento comeÃ§arÃ¡ em 30 minutos (entre 29 e 31 minutos para dar uma margem)
          if (diffMinutes >= 29 && diffMinutes <= 31) {
            console.log(`Evento ${event.name} comeÃ§arÃ¡ em aproximadamente 30 minutos (${diffMinutes.toFixed(2)} min)`)

            // Formatar a hora do evento
            const eventTimeStr = nextEventTime.toLocaleTimeString("pt-BR", {
              hour: "2-digit",
              minute: "2-digit",
            })

            // Formatar a data do evento
            const eventDateStr = nextEventTime.toLocaleDateString("pt-BR", {
              day: "2-digit",
              month: "2-digit",
            })

            // Criar a mensagem
            const message = `ðŸŽ® *Aion Classic Timer* ðŸŽ®\n\nO evento *${event.name}* comeÃ§arÃ¡ em 30 minutos (${eventDateStr} Ã s ${eventTimeStr})! Prepare-se!`

            // Enviar a notificaÃ§Ã£o
            console.log(`Enviando notificaÃ§Ã£o para ${subscriber.phone_number} sobre o evento ${event.name}`)
            const result = await sendWhatsAppMessage(subscriber.phone_number, message)
            console.log("Resultado do envio:", result)

            notificationResults.push({
              subscriber: subscriber.phone_number,
              event: event.name,
              success: result.success,
              error: result.success ? null : result.error,
              isTest: false,
              testMode: result.testMode || false,
            })
          } else {
            console.log(`Evento ${event.name} nÃ£o estÃ¡ prÃ³ximo de comeÃ§ar (${diffMinutes.toFixed(2)} min)`)
          }
        } else {
          console.log(`NÃ£o foi possÃ­vel determinar o prÃ³ximo horÃ¡rio para o evento ${event.name}`)
        }
      }
    }

    console.log(`VerificaÃ§Ã£o concluÃ­da. ${notificationResults.length} notificaÃ§Ãµes enviadas.`)
    return {
      success: true,
      message:
        notificationResults.length > 0
          ? `VerificaÃ§Ã£o concluÃ­da. ${notificationResults.length} notificaÃ§Ãµes enviadas.`
          : "VerificaÃ§Ã£o concluÃ­da. Nenhum evento estÃ¡ prestes a comeÃ§ar.",
      notificationsSent: notificationResults.length,
      results: notificationResults,
    }
  } catch (error) {
    console.error("Erro ao verificar eventos prÃ³ximos:", error)
    return {
      success: false,
      error: `Erro ao verificar eventos prÃ³ximos: ${error instanceof Error ? error.message : "Erro desconhecido"}`,
    }
  }
}

// FunÃ§Ã£o auxiliar para obter o prÃ³ximo horÃ¡rio de um evento
function getNextEventTime(event: Event, currentTime: Date): Date | null {
  // Obter o dia atual da semana (0 = Domingo, 1 = Segunda, ..., 6 = SÃ¡bado)
  const currentDay = currentTime.getDay()
  // Converter para nosso formato (0 = Segunda, ..., 6 = Domingo)
  const adjustedCurrentDay = currentDay === 0 ? 6 : currentDay - 1

  // Verificar se o evento ocorre no dia atual
  const eventDays = Array.isArray(event.day) ? event.day : [event.day]

  // Encontrar a prÃ³xima data do evento
  let nextDate: Date | null = null
  let minDiffMs = Number.POSITIVE_INFINITY

  // Verificar todos os dias da semana
  for (let dayOffset = 0; dayOffset < 7; dayOffset++) {
    const checkDay = (adjustedCurrentDay + dayOffset) % 7

    // Verificar se o evento ocorre neste dia
    if (eventDays.includes(checkDay)) {
      // Processar eventos com mÃºltiplos horÃ¡rios de abertura
      if (event.openTimes && event.openTimes.length > 0) {
        for (const openTime of event.openTimes) {
          // Verificar se openTime Ã© uma string vÃ¡lida
          if (typeof openTime !== "string") {
            console.error(`Formato invÃ¡lido para openTime no evento ${event.name}:`, openTime)
            continue
          }

          const timeParts = openTime.split(":")
          if (timeParts.length !== 2) {
            console.error(`Formato invÃ¡lido para openTime no evento ${event.name}: ${openTime}`)
            continue
          }

          const openHour = Number.parseInt(timeParts[0], 10)
          const openMinute = Number.parseInt(timeParts[1], 10)

          if (isNaN(openHour) || isNaN(openMinute)) {
            console.error(`Valores invÃ¡lidos para openTime no evento ${event.name}: ${openTime}`)
            continue
          }

          // Criar data para este horÃ¡rio
          const openDate = new Date(currentTime)
          openDate.setDate(currentTime.getDate() + dayOffset)
          openDate.setHours(openHour, openMinute, 0, 0)

          // Se este horÃ¡rio jÃ¡ passou hoje, ignorar
          if (dayOffset === 0 && openDate < currentTime) continue

          const diffMs = openDate.getTime() - currentTime.getTime()
          if (diffMs < minDiffMs) {
            minDiffMs = diffMs
            nextDate = openDate
          }
        }
      }
      // Processar eventos com horÃ¡rio Ãºnico
      else if (event.time) {
        // Verificar se time Ã© uma string vÃ¡lida
        if (typeof event.time !== "string") {
          console.error(`Formato invÃ¡lido para time no evento ${event.name}:`, event.time)
          continue
        }

        const timeParts = event.time.split(":")
        if (timeParts.length !== 2) {
          console.error(`Formato invÃ¡lido para time no evento ${event.name}: ${event.time}`)
          continue
        }

        const eventHour = Number.parseInt(timeParts[0], 10)
        const eventMinute = Number.parseInt(timeParts[1], 10)

        if (isNaN(eventHour) || isNaN(eventMinute)) {
          console.error(`Valores invÃ¡lidos para time no evento ${event.name}: ${event.time}`)
          continue
        }

        // Criar data para este horÃ¡rio
        const openDate = new Date(currentTime)
        openDate.setDate(currentTime.getDate() + dayOffset)
        openDate.setHours(eventHour, eventMinute, 0, 0)

        // Se este horÃ¡rio jÃ¡ passou hoje, ignorar
        if (dayOffset === 0 && openDate < currentTime) continue

        const diffMs = openDate.getTime() - currentTime.getTime()
        if (diffMs < minDiffMs) {
          minDiffMs = diffMs
          nextDate = openDate
        }
      }
    }
  }

  return nextDate
}
